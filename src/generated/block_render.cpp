// Generated by py/gen_face_bitfields.py on 10:49AM, February 23, 2019

bool BLOCK_SIDE_OCCLUSION_BITFIELD[] = {
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, false, false, false, false, false,
    false, false, true,  false, true,  true,  true,  true,  true,  false, false,
    false, false, true,  false, false, false, false, false, true,  true,  true,
    true,  true,  false, false, false, false, true,  false, false, false, false,
    false, false, false, false, true,  false, true,  true,  true,  true,  true,
    false, false, false, false, false, true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  false, false, false, false, true,  false, false,
    false, false, false, false, false, false, true,  false, false, false, false,
    false, false, true,  true,  true,  true,  true,  false, false, false, true,
    false, true,  true,  true,  true,  true,  false, false, false, false, true,
    false, false, false, false, false, false, false, false, false, false, true,
    true,  true,  true,  true,  false, false, false, false, false, false, false,
    true,  false, false, true,  true,  true,  true,  true,  false, true,  false,
    false, false, true,  true,  true,  true,  true,  false, false, false, false,
    false, false, true,  false, false, false, false, false, false, false, false,
    false, false, true,  false, false, true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  false, false, false, false, false, true,  true,
    true,  true,  true,  false, true,  false, false, false, false, false, false,
    false, false, false, false, true,  false, false, true,  true,  true,  true,
    true,  false, false, false, false, false, false, false, true,  false, false,
    true,  true,  true,  true,  true,  false, true,  false, false, false, false,
    false, false, false, false, true,  true,  true,  true,  true,  false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    true,  false, false, false, false, false, true,  false, false, false, false,
    false, false, false, false, false, false, false, true,  false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, true,  false, false, false, false, false, true,  false, false,
    false, false, false, false, false, true,  false, false, false, false, false,
    false, true,  false, false, false, false, false, false, false, false, false,
    false, false, false, false, true,  false, false, false, false, false, false,
    false, false, false, true,  false, false, false, false, true,  false, false,
    false, false, false, true,  false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, true,  false, false, false, false, false, false, false, true,  false,
    false, false, true,  false, false, false, false, false, false, false, false,
    false, false, false, false, true,  false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    true,  false, false, false, true,  false, false, false, false, false, false,
    true,  false, false, false, false, false, false, false, true,  false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, true,  false, false, false, false, true,  false, false, false,
    false, false, false, false, false, false, true,  false, false, false, true,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, true,  false, false, false, false, false, false, false,
    false, true,  true,  true,  true,  true,  false, false, false, false, true,
    false, false, false, true,  false, true,  true,  true,  true,  true,  false,
    false, true,  false, false, true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  true,  false, false, false,
    false, true,  false, false, false, true,  false, false, true,  false, false,
    false, true,  true,  true,  true,  true,  false, false, false, true,  false,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  false,
    false, false, false, true,  false, false, false, false, true,  true,  true,
    true,  true,  true,  false, false, false, false, true,  false, false, false,
    true,  false, true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  false, false, false, true,  false, true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, true,  false, false, false, false,
    false, true,  false, false, true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  false, false, false, true,  false, true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  false, true,  false, false,
    false, false, false, true,  false, false, true,  true,  true,  true,  true,
    false, false, false, false, true,  false, false, true,  false, false, true,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  false, true,
    false, false, false, true,  true,  true,  true,  true,  false, true,  false,
    false, false, false, true,  false, false, false, false, false, true,  false,
    false, true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, false, true,  false, false, false,
    false, false, false, false, true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  false, false, false, false, false, false, false, false,
    false, true,  false, true,  false, false, false, false, false, false, false,
    false, false, false, false, false, false, true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, false, false, true,  false, false,
    false, true,  false, false, true,  true,  true,  true,  true,  false, false,
    false, false, false, false, false, false, false, false, true,  true,  true,
    true,  true,  false, false, true,  false, false, false, false, false, true,
    false, true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    false, false, false, false, false, false, false, false, false, false, false,
    true,  false, false, false, false, false, false, false, true};

inline bool *getBlockSideOcclusion(BlockShape block_shape, Direction side) {
  return BLOCK_SIDE_OCCLUSION_BITFIELD + (block_shape * 30 + side * 5);
}

void pushBlockVertices(ChunkVertex **vertex_cursor, Chunk *chunk,
                       LoadedWorld *world, int x, int y, int z,
                       BlockShape block_shape) {
  bool *block_side_occulusion;

  float fx = x;
  float fy = y;
  float fz = z;
  V3 xyz = {fx, fy, fz};
  V3 Xyz = {fx + 1, fy, fz};
  V3 xYz = {fx, fy + 1, fz};
  V3 xyZ = {fx, fy, fz + 1};
  V3 xYZ = {fx, fy + 1, fz + 1};
  V3 XyZ = {fx + 1, fy, fz + 1};
  V3 XYz = {fx + 1, fy + 1, fz};
  V3 XYZ = {fx + 1, fy + 1, fz + 1};

  // POS_Z
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y, z + 1), NEG_Z);
  switch (block_shape) {
  case CUBE:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNERLESS:
  case NEG_POS_NEG_CORNERLESS:
  case POS_NEG_NEG_CORNERLESS:
  case NEG_NEG_NEG_CORNERLESS:
  case NEG_POS_DIAGONAL:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    PUSH_SQUARE(*vertex_cursor, xyZ, XyZ, XYZ, xYZ, BETH);
    break;

  case NEG_X_NEG_Y_SLOPE:
  case POS_POS_POS_CORNER:
  case NEG_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, XyZ, XYZ, xYZ, BETH);
    break;

  case POS_X_NEG_Y_SLOPE:
  case NEG_POS_POS_CORNER:
  case POS_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyZ, XYZ, xYZ, BETH);
    break;

  case POS_X_POS_Y_SLOPE:
  case NEG_NEG_POS_CORNER:
  case POS_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyZ, XyZ, xYZ, BETH);
    break;

  case NEG_X_POS_Y_SLOPE:
  case POS_NEG_POS_CORNER:
  case NEG_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyZ, XyZ, XYZ, BETH);
    break;

  case AIR:
  case POS_Z_POS_Y_SLOPE:
  case POS_Z_NEG_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case NEG_NEG_NEG_CORNER:
  case POS_POS_NEG_CORNER:
  case NEG_POS_NEG_CORNER:
  case POS_NEG_DIAGONAL:
  case NEG_NEG_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // POS_X
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x + 1, y, z), NEG_X);
  switch (block_shape) {
  case CUBE:
  case NEG_X_POS_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case NEG_POS_NEG_CORNERLESS:
  case NEG_POS_POS_CORNERLESS:
  case NEG_NEG_NEG_CORNERLESS:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    PUSH_SQUARE(*vertex_cursor, XyZ, Xyz, XYz, XYZ, BETH);
    break;

  case POS_Z_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNER:
  case POS_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, Xyz, XYz, XYZ, BETH);
    break;

  case NEG_Z_NEG_Y_SLOPE:
  case POS_POS_POS_CORNER:
  case POS_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, XyZ, XYz, XYZ, BETH);
    break;

  case NEG_Z_POS_Y_SLOPE:
  case POS_NEG_POS_CORNER:
  case POS_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, XyZ, Xyz, XYZ, BETH);
    break;

  case POS_Z_POS_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case POS_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, XyZ, Xyz, XYz, BETH);
    break;

  case AIR:
  case POS_X_POS_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case NEG_NEG_NEG_CORNER:
  case NEG_NEG_POS_CORNER:
  case NEG_POS_NEG_CORNER:
  case NEG_POS_POS_CORNER:
  case NEG_NEG_DIAGONAL:
  case NEG_POS_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // NEG_Z
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y, z - 1), POS_Z);
  switch (block_shape) {
  case CUBE:
  case POS_Z_POS_Y_SLOPE:
  case POS_Z_NEG_Y_SLOPE:
  case NEG_POS_POS_CORNERLESS:
  case POS_POS_POS_CORNERLESS:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
  case NEG_NEG_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    PUSH_SQUARE(*vertex_cursor, Xyz, xyz, xYz, XYz, BETH);
    break;

  case POS_X_NEG_Y_SLOPE:
  case NEG_POS_NEG_CORNER:
  case POS_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyz, xYz, XYz, BETH);
    break;

  case NEG_X_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNER:
  case NEG_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, Xyz, xYz, XYz, BETH);
    break;

  case NEG_X_POS_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case NEG_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, Xyz, xyz, XYz, BETH);
    break;

  case POS_X_POS_Y_SLOPE:
  case NEG_NEG_NEG_CORNER:
  case POS_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, Xyz, xyz, xYz, BETH);
    break;

  case AIR:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case NEG_NEG_POS_CORNER:
  case POS_NEG_POS_CORNER:
  case NEG_POS_POS_CORNER:
  case POS_POS_POS_CORNER:
  case NEG_POS_DIAGONAL:
  case POS_POS_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // NEG_X
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x - 1, y, z), POS_X);
  switch (block_shape) {
  case CUBE:
  case POS_X_POS_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNERLESS:
  case POS_POS_POS_CORNERLESS:
  case POS_NEG_NEG_CORNERLESS:
  case POS_NEG_POS_CORNERLESS:
  case NEG_NEG_DIAGONAL:
  case NEG_POS_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    PUSH_SQUARE(*vertex_cursor, xyz, xyZ, xYZ, xYz, BETH);
    break;

  case NEG_Z_NEG_Y_SLOPE:
  case NEG_POS_POS_CORNER:
  case NEG_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyZ, xYZ, xYz, BETH);
    break;

  case POS_Z_NEG_Y_SLOPE:
  case NEG_POS_NEG_CORNER:
  case NEG_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyz, xYZ, xYz, BETH);
    break;

  case POS_Z_POS_Y_SLOPE:
  case NEG_NEG_NEG_CORNER:
  case NEG_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyz, xyZ, xYz, BETH);
    break;

  case NEG_Z_POS_Y_SLOPE:
  case NEG_NEG_POS_CORNER:
  case NEG_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyz, xyZ, xYZ, BETH);
    break;

  case AIR:
  case NEG_X_POS_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case POS_NEG_POS_CORNER:
  case POS_POS_NEG_CORNER:
  case POS_POS_POS_CORNER:
  case POS_NEG_DIAGONAL:
  case POS_POS_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // POS_Y
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y + 1, z), NEG_Y);
  switch (block_shape) {
  case CUBE:
  case POS_Z_NEG_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case POS_NEG_NEG_CORNERLESS:
  case NEG_NEG_NEG_CORNERLESS:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_POS_CORNERLESS:
    if (block_side_occulusion[FULL]) {
      break;
    }
    PUSH_SQUARE(*vertex_cursor, xYZ, XYZ, XYz, xYz, GREEN);
    break;

  case POS_POS_NEG_CORNER:
  case NEG_POS_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, XYZ, XYz, xYz, GREEN);
    break;

  case NEG_POS_NEG_CORNER:
  case POS_POS_POS_CORNERLESS:
  case NEG_NEG_DIAGONAL:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xYZ, XYz, xYz, GREEN);
    break;

  case NEG_POS_POS_CORNER:
  case POS_POS_NEG_CORNERLESS:
  case NEG_POS_DIAGONAL:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xYZ, XYZ, xYz, GREEN);
    break;

  case POS_POS_POS_CORNER:
  case NEG_POS_NEG_CORNERLESS:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xYZ, XYZ, XYz, GREEN);
    break;

  case AIR:
  case POS_Z_POS_Y_SLOPE:
  case POS_X_POS_Y_SLOPE:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_X_POS_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case NEG_NEG_NEG_CORNER:
  case NEG_NEG_POS_CORNER:
  case POS_NEG_POS_CORNER:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // NEG_Y
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y - 1, z), POS_Y);
  switch (block_shape) {
  case CUBE:
  case POS_Z_POS_Y_SLOPE:
  case POS_X_POS_Y_SLOPE:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_X_POS_Y_SLOPE:
  case POS_POS_NEG_CORNERLESS:
  case NEG_POS_NEG_CORNERLESS:
  case NEG_POS_POS_CORNERLESS:
  case POS_POS_POS_CORNERLESS:
    if (block_side_occulusion[FULL]) {
      break;
    }
    PUSH_SQUARE(*vertex_cursor, xyz, Xyz, XyZ, xyZ, BETH);
    break;

  case POS_NEG_POS_CORNER:
  case NEG_NEG_NEG_CORNERLESS:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, Xyz, XyZ, xyZ, BETH);
    break;

  case NEG_NEG_POS_CORNER:
  case POS_NEG_NEG_CORNERLESS:
  case NEG_POS_DIAGONAL:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyz, XyZ, xyZ, BETH);
    break;

  case NEG_NEG_NEG_CORNER:
  case POS_NEG_POS_CORNERLESS:
  case NEG_NEG_DIAGONAL:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyz, Xyz, xyZ, BETH);
    break;

  case POS_NEG_NEG_CORNER:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    PUSH_TRIANGLE(*vertex_cursor, xyz, Xyz, XyZ, BETH);
    break;

  case AIR:
  case POS_Z_NEG_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNER:
  case NEG_POS_NEG_CORNER:
  case NEG_POS_POS_CORNER:
  case POS_POS_POS_CORNER:
  case BLOCK_SHAPE_COUNT:
    break;
  }
}
