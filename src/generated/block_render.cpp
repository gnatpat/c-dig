// Generated by generate_block_render_code.py on 05:08PM, February 23, 2019

bool BLOCK_SIDE_OCCLUSION_BITFIELD[] = {
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, false, false, false, false, false,
    false, false, true,  false, true,  true,  true,  true,  true,  false, false,
    false, false, true,  false, false, false, false, false, true,  true,  true,
    true,  true,  false, false, false, false, true,  false, false, false, false,
    false, false, false, false, true,  false, true,  true,  true,  true,  true,
    false, false, false, false, false, true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  false, false, false, false, true,  false, false,
    false, false, false, false, false, false, true,  false, false, false, false,
    false, false, true,  true,  true,  true,  true,  false, false, false, true,
    false, true,  true,  true,  true,  true,  false, false, false, false, true,
    false, false, false, false, false, false, false, false, false, false, true,
    true,  true,  true,  true,  false, false, false, false, false, false, false,
    true,  false, false, true,  true,  true,  true,  true,  false, true,  false,
    false, false, true,  true,  true,  true,  true,  false, false, false, false,
    false, false, true,  false, false, false, false, false, false, false, false,
    false, false, true,  false, false, true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  false, false, false, false, false, true,  true,
    true,  true,  true,  false, true,  false, false, false, false, false, false,
    false, false, false, false, true,  false, false, true,  true,  true,  true,
    true,  false, false, false, false, false, false, false, true,  false, false,
    true,  true,  true,  true,  true,  false, true,  false, false, false, false,
    false, false, false, false, true,  true,  true,  true,  true,  false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    true,  false, false, false, false, false, true,  false, false, false, false,
    false, false, false, false, false, false, false, true,  false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, true,  false, false, false, false, false, true,  false, false,
    false, false, false, false, false, true,  false, false, false, false, false,
    false, true,  false, false, false, false, false, false, false, false, false,
    false, false, false, false, true,  false, false, false, false, false, false,
    false, false, false, true,  false, false, false, false, true,  false, false,
    false, false, false, true,  false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, true,  false, false, false, false, false, false, false, true,  false,
    false, false, true,  false, false, false, false, false, false, false, false,
    false, false, false, false, true,  false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    true,  false, false, false, true,  false, false, false, false, false, false,
    true,  false, false, false, false, false, false, false, true,  false, false,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, true,  false, false, false, false, true,  false, false, false,
    false, false, false, false, false, false, true,  false, false, false, true,
    false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, true,  false, false, false, false, false, false, false,
    false, true,  true,  true,  true,  true,  false, false, false, false, true,
    false, false, false, true,  false, true,  true,  true,  true,  true,  false,
    false, true,  false, false, true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  true,  false, false, false,
    false, true,  false, false, false, true,  false, false, true,  false, false,
    false, true,  true,  true,  true,  true,  false, false, false, true,  false,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  true,  false,
    false, false, false, true,  false, false, false, false, true,  true,  true,
    true,  true,  true,  false, false, false, false, true,  false, false, false,
    true,  false, true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  false, false, false, true,  false, true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, true,  false, false, false, false,
    false, true,  false, false, true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  false, false, false, true,  false, true,  true,  true,
    true,  true,  true,  true,  true,  true,  true,  false, true,  false, false,
    false, false, false, true,  false, false, true,  true,  true,  true,  true,
    false, false, false, false, true,  false, false, true,  false, false, true,
    true,  true,  true,  true,  true,  true,  true,  true,  true,  false, true,
    false, false, false, true,  true,  true,  true,  true,  false, true,  false,
    false, false, false, true,  false, false, false, false, false, true,  false,
    false, true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, false, true,  false, false, false,
    false, false, false, false, true,  true,  true,  true,  true,  true,  true,
    true,  true,  true,  false, false, false, false, false, false, false, false,
    false, true,  false, true,  false, false, false, false, false, false, false,
    false, false, false, false, false, false, true,  true,  true,  true,  true,
    true,  true,  true,  true,  true,  false, false, false, true,  false, false,
    false, true,  false, false, true,  true,  true,  true,  true,  false, false,
    false, false, false, false, false, false, false, false, true,  true,  true,
    true,  true,  false, false, true,  false, false, false, false, false, true,
    false, true,  true,  true,  true,  true,  true,  true,  true,  true,  true,
    false, false, false, false, false, false, false, false, false, false, false,
    true,  false, false, false, false, false, false, false, true};

inline bool *getBlockSideOcclusion(BlockShape block_shape, Direction side) {
  return BLOCK_SIDE_OCCLUSION_BITFIELD + (block_shape * 30 + side * 5);
}

void pushBlockVertices(ChunkVertex **vertex_cursor, Chunk *chunk,
                       LoadedWorld *world, int x, int y, int z,
                       BlockShape block_shape) {
  bool *block_side_occulusion;
  V3 normal;

  float fx = x;
  float fy = y;
  float fz = z;
  V3 xyz = {fx, fy, fz};
  V3 Xyz = {fx + 1, fy, fz};
  V3 xYz = {fx, fy + 1, fz};
  V3 xyZ = {fx, fy, fz + 1};
  V3 xYZ = {fx, fy + 1, fz + 1};
  V3 XyZ = {fx + 1, fy, fz + 1};
  V3 XYz = {fx + 1, fy + 1, fz};
  V3 XYZ = {fx + 1, fy + 1, fz + 1};

  // POS_Z
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y, z + 1), NEG_Z);
  normal = v3(0, 0, 1);
  switch (block_shape) {
  case CUBE:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNERLESS:
  case NEG_POS_NEG_CORNERLESS:
  case POS_NEG_NEG_CORNERLESS:
  case NEG_NEG_NEG_CORNERLESS:
  case NEG_POS_DIAGONAL:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    pushSquare(vertex_cursor, xyZ, XyZ, XYZ, xYZ, BETH, normal);
    break;

  case NEG_X_NEG_Y_SLOPE:
  case POS_POS_POS_CORNER:
  case NEG_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, XyZ, XYZ, xYZ, BETH, normal);
    break;

  case POS_X_NEG_Y_SLOPE:
  case NEG_POS_POS_CORNER:
  case POS_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyZ, XYZ, xYZ, BETH, normal);
    break;

  case POS_X_POS_Y_SLOPE:
  case NEG_NEG_POS_CORNER:
  case POS_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyZ, XyZ, xYZ, BETH, normal);
    break;

  case NEG_X_POS_Y_SLOPE:
  case POS_NEG_POS_CORNER:
  case NEG_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyZ, XyZ, XYZ, BETH, normal);
    break;

  case AIR:
  case POS_Z_POS_Y_SLOPE:
  case POS_Z_NEG_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case NEG_NEG_NEG_CORNER:
  case POS_POS_NEG_CORNER:
  case NEG_POS_NEG_CORNER:
  case POS_NEG_DIAGONAL:
  case NEG_NEG_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // POS_X
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x + 1, y, z), NEG_X);
  normal = v3(1, 0, 0);
  switch (block_shape) {
  case CUBE:
  case NEG_X_POS_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case NEG_POS_NEG_CORNERLESS:
  case NEG_POS_POS_CORNERLESS:
  case NEG_NEG_NEG_CORNERLESS:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    pushSquare(vertex_cursor, XyZ, Xyz, XYz, XYZ, BETH, normal);
    break;

  case POS_Z_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNER:
  case POS_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, Xyz, XYz, XYZ, BETH, normal);
    break;

  case NEG_Z_NEG_Y_SLOPE:
  case POS_POS_POS_CORNER:
  case POS_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, XyZ, XYz, XYZ, BETH, normal);
    break;

  case NEG_Z_POS_Y_SLOPE:
  case POS_NEG_POS_CORNER:
  case POS_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, XyZ, Xyz, XYZ, BETH, normal);
    break;

  case POS_Z_POS_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case POS_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, XyZ, Xyz, XYz, BETH, normal);
    break;

  case AIR:
  case POS_X_POS_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case NEG_NEG_NEG_CORNER:
  case NEG_NEG_POS_CORNER:
  case NEG_POS_NEG_CORNER:
  case NEG_POS_POS_CORNER:
  case NEG_NEG_DIAGONAL:
  case NEG_POS_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // NEG_Z
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y, z - 1), POS_Z);
  normal = v3(0, 0, -1);
  switch (block_shape) {
  case CUBE:
  case POS_Z_POS_Y_SLOPE:
  case POS_Z_NEG_Y_SLOPE:
  case NEG_POS_POS_CORNERLESS:
  case POS_POS_POS_CORNERLESS:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
  case NEG_NEG_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    pushSquare(vertex_cursor, Xyz, xyz, xYz, XYz, BETH, normal);
    break;

  case POS_X_NEG_Y_SLOPE:
  case NEG_POS_NEG_CORNER:
  case POS_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyz, xYz, XYz, BETH, normal);
    break;

  case NEG_X_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNER:
  case NEG_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, Xyz, xYz, XYz, BETH, normal);
    break;

  case NEG_X_POS_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case NEG_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, Xyz, xyz, XYz, BETH, normal);
    break;

  case POS_X_POS_Y_SLOPE:
  case NEG_NEG_NEG_CORNER:
  case POS_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, Xyz, xyz, xYz, BETH, normal);
    break;

  case AIR:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case NEG_NEG_POS_CORNER:
  case POS_NEG_POS_CORNER:
  case NEG_POS_POS_CORNER:
  case POS_POS_POS_CORNER:
  case NEG_POS_DIAGONAL:
  case POS_POS_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // NEG_X
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x - 1, y, z), POS_X);
  normal = v3(-1, 0, 0);
  switch (block_shape) {
  case CUBE:
  case POS_X_POS_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNERLESS:
  case POS_POS_POS_CORNERLESS:
  case POS_NEG_NEG_CORNERLESS:
  case POS_NEG_POS_CORNERLESS:
  case NEG_NEG_DIAGONAL:
  case NEG_POS_DIAGONAL:
    if (block_side_occulusion[FULL]) {
      break;
    }
    pushSquare(vertex_cursor, xyz, xyZ, xYZ, xYz, BETH, normal);
    break;

  case NEG_Z_NEG_Y_SLOPE:
  case NEG_POS_POS_CORNER:
  case NEG_NEG_NEG_CORNERLESS:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyZ, xYZ, xYz, BETH, normal);
    break;

  case POS_Z_NEG_Y_SLOPE:
  case NEG_POS_NEG_CORNER:
  case NEG_NEG_POS_CORNERLESS:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyz, xYZ, xYz, BETH, normal);
    break;

  case POS_Z_POS_Y_SLOPE:
  case NEG_NEG_NEG_CORNER:
  case NEG_POS_POS_CORNERLESS:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyz, xyZ, xYz, BETH, normal);
    break;

  case NEG_Z_POS_Y_SLOPE:
  case NEG_NEG_POS_CORNER:
  case NEG_POS_NEG_CORNERLESS:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyz, xyZ, xYZ, BETH, normal);
    break;

  case AIR:
  case NEG_X_POS_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case POS_NEG_POS_CORNER:
  case POS_POS_NEG_CORNER:
  case POS_POS_POS_CORNER:
  case POS_NEG_DIAGONAL:
  case POS_POS_DIAGONAL:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // POS_Y
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y + 1, z), NEG_Y);
  normal = v3(0, 1, 0);
  switch (block_shape) {
  case CUBE:
  case POS_Z_NEG_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case POS_NEG_NEG_CORNERLESS:
  case NEG_NEG_NEG_CORNERLESS:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_POS_CORNERLESS:
    if (block_side_occulusion[FULL]) {
      break;
    }
    pushSquare(vertex_cursor, xYZ, XYZ, XYz, xYz, GREEN, normal);
    break;

  case POS_POS_NEG_CORNER:
  case NEG_POS_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, XYZ, XYz, xYz, GREEN, normal);
    break;

  case NEG_POS_NEG_CORNER:
  case POS_POS_POS_CORNERLESS:
  case NEG_NEG_DIAGONAL:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xYZ, XYz, xYz, GREEN, normal);
    break;

  case NEG_POS_POS_CORNER:
  case POS_POS_NEG_CORNERLESS:
  case NEG_POS_DIAGONAL:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xYZ, XYZ, xYz, GREEN, normal);
    break;

  case POS_POS_POS_CORNER:
  case NEG_POS_NEG_CORNERLESS:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, xYZ, XYZ, XYz, GREEN, normal);
    break;

  case AIR:
  case POS_Z_POS_Y_SLOPE:
  case POS_X_POS_Y_SLOPE:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_X_POS_Y_SLOPE:
  case POS_NEG_NEG_CORNER:
  case NEG_NEG_NEG_CORNER:
  case NEG_NEG_POS_CORNER:
  case POS_NEG_POS_CORNER:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // NEG_Y
  block_side_occulusion =
      getBlockSideOcclusion(getBlockShapeAt(world, chunk, x, y - 1, z), POS_Y);
  normal = v3(0, -1, 0);
  switch (block_shape) {
  case CUBE:
  case POS_Z_POS_Y_SLOPE:
  case POS_X_POS_Y_SLOPE:
  case NEG_Z_POS_Y_SLOPE:
  case NEG_X_POS_Y_SLOPE:
  case POS_POS_NEG_CORNERLESS:
  case NEG_POS_NEG_CORNERLESS:
  case NEG_POS_POS_CORNERLESS:
  case POS_POS_POS_CORNERLESS:
    if (block_side_occulusion[FULL]) {
      break;
    }
    pushSquare(vertex_cursor, xyz, Xyz, XyZ, xyZ, BETH, normal);
    break;

  case POS_NEG_POS_CORNER:
  case NEG_NEG_NEG_CORNERLESS:
  case POS_POS_DIAGONAL:
    if (block_side_occulusion[TOP_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, Xyz, XyZ, xyZ, BETH, normal);
    break;

  case NEG_NEG_POS_CORNER:
  case POS_NEG_NEG_CORNERLESS:
  case NEG_POS_DIAGONAL:
    if (block_side_occulusion[TOP_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyz, XyZ, xyZ, BETH, normal);
    break;

  case NEG_NEG_NEG_CORNER:
  case POS_NEG_POS_CORNERLESS:
  case NEG_NEG_DIAGONAL:
    if (block_side_occulusion[BOTTOM_LEFT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyz, Xyz, xyZ, BETH, normal);
    break;

  case POS_NEG_NEG_CORNER:
  case NEG_NEG_POS_CORNERLESS:
  case POS_NEG_DIAGONAL:
    if (block_side_occulusion[BOTTOM_RIGHT]) {
      break;
    }
    pushTriangle(vertex_cursor, xyz, Xyz, XyZ, BETH, normal);
    break;

  case AIR:
  case POS_Z_NEG_Y_SLOPE:
  case POS_X_NEG_Y_SLOPE:
  case NEG_Z_NEG_Y_SLOPE:
  case NEG_X_NEG_Y_SLOPE:
  case POS_POS_NEG_CORNER:
  case NEG_POS_NEG_CORNER:
  case NEG_POS_POS_CORNER:
  case POS_POS_POS_CORNER:
  case BLOCK_SHAPE_COUNT:
    break;
  }

  // SLOPES
  switch (block_shape) {
  case AIR:
    break;
  case CUBE:
    break;
  case POS_Z_POS_Y_SLOPE:
    pushSquare(vertex_cursor, xyZ, XyZ, XYz, xYz, GREEN, v3(0, 1, 1));
    break;
  case POS_X_POS_Y_SLOPE:
    pushSquare(vertex_cursor, XyZ, Xyz, xYz, xYZ, GREEN, v3(1, 1, 0));
    break;
  case NEG_Z_POS_Y_SLOPE:
    pushSquare(vertex_cursor, Xyz, xyz, xYZ, XYZ, GREEN, v3(0, 1, -1));
    break;
  case NEG_X_POS_Y_SLOPE:
    pushSquare(vertex_cursor, xyz, xyZ, XYZ, XYz, GREEN, v3(-1, 1, 0));
    break;
  case POS_Z_NEG_Y_SLOPE:
    pushSquare(vertex_cursor, Xyz, XYZ, xYZ, xyz, GREEN, v3(0, -1, 1));
    break;
  case POS_X_NEG_Y_SLOPE:
    pushSquare(vertex_cursor, xyz, XYz, XYZ, xyZ, GREEN, v3(1, -1, 0));
    break;
  case NEG_Z_NEG_Y_SLOPE:
    pushSquare(vertex_cursor, xyZ, xYz, XYz, XyZ, GREEN, v3(0, -1, -1));
    break;
  case NEG_X_NEG_Y_SLOPE:
    pushSquare(vertex_cursor, XyZ, xYZ, xYz, Xyz, GREEN, v3(-1, -1, 0));
    break;
  case POS_NEG_NEG_CORNER:
    pushTriangle(vertex_cursor, XYz, xyz, XyZ, GREEN, v3(-1, 1, 1));
    break;
  case NEG_NEG_NEG_CORNER:
    pushTriangle(vertex_cursor, xYz, xyZ, Xyz, GREEN, v3(1, 1, 1));
    break;
  case NEG_NEG_POS_CORNER:
    pushTriangle(vertex_cursor, xYZ, XyZ, xyz, GREEN, v3(1, 1, -1));
    break;
  case POS_NEG_POS_CORNER:
    pushTriangle(vertex_cursor, XYZ, Xyz, xyZ, GREEN, v3(-1, 1, -1));
    break;
  case POS_POS_NEG_CORNER:
    pushTriangle(vertex_cursor, Xyz, XYZ, xYz, GREEN, v3(-1, -1, 1));
    break;
  case NEG_POS_NEG_CORNER:
    pushTriangle(vertex_cursor, xyz, XYz, xYZ, GREEN, v3(1, -1, 1));
    break;
  case NEG_POS_POS_CORNER:
    pushTriangle(vertex_cursor, xyZ, xYz, XYZ, GREEN, v3(1, -1, -1));
    break;
  case POS_POS_POS_CORNER:
    pushTriangle(vertex_cursor, XyZ, xYZ, XYz, GREEN, v3(-1, -1, -1));
    break;
  case POS_POS_NEG_CORNERLESS:
    pushTriangle(vertex_cursor, XYZ, Xyz, xYz, GREEN, v3(1, 1, -1));
    break;
  case NEG_POS_NEG_CORNERLESS:
    pushTriangle(vertex_cursor, XYz, xyz, xYZ, GREEN, v3(-1, 1, -1));
    break;
  case NEG_POS_POS_CORNERLESS:
    pushTriangle(vertex_cursor, xYz, xyZ, XYZ, GREEN, v3(-1, 1, 1));
    break;
  case POS_POS_POS_CORNERLESS:
    pushTriangle(vertex_cursor, xYZ, XyZ, XYz, GREEN, v3(1, 1, 1));
    break;
  case POS_NEG_NEG_CORNERLESS:
    pushTriangle(vertex_cursor, XYz, XyZ, xyz, GREEN, v3(1, -1, -1));
    break;
  case NEG_NEG_NEG_CORNERLESS:
    pushTriangle(vertex_cursor, xYz, Xyz, xyZ, GREEN, v3(-1, -1, -1));
    break;
  case NEG_NEG_POS_CORNERLESS:
    pushTriangle(vertex_cursor, xYZ, xyz, XyZ, GREEN, v3(-1, -1, 1));
    break;
  case POS_NEG_POS_CORNERLESS:
    pushTriangle(vertex_cursor, XYZ, xyZ, Xyz, GREEN, v3(1, -1, 1));
    break;
  case POS_NEG_DIAGONAL:
    pushSquare(vertex_cursor, XyZ, XYZ, xYz, xyz, GREEN, v3(-1, 0, 1));
    break;
  case NEG_NEG_DIAGONAL:
    pushSquare(vertex_cursor, Xyz, XYz, xYZ, xyZ, GREEN, v3(1, 0, 1));
    break;
  case NEG_POS_DIAGONAL:
    pushSquare(vertex_cursor, xyz, xYz, XYZ, XyZ, GREEN, v3(1, 0, -1));
    break;
  case POS_POS_DIAGONAL:
    pushSquare(vertex_cursor, xyZ, xYZ, XYz, Xyz, GREEN, v3(-1, 0, -1));
    break;
  case BLOCK_SHAPE_COUNT:
    break;
  }
}
